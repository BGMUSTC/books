# 第一章 介绍

[原文连接](https://docs.oracle.com/javase/specs/jls/se8/html/jls-1.html)

Java 是一个通用、支持并发、基于类结构的面向对象的编程语言。它的设计非常简单，因此很多程序员可以很容易地掌握它。Java 编程语言起源于 C 和 C++，但是减掉了这两个编程语言里的一些特性，并且引入了一些其他编程语言的特性。Java 旨在成为一个生产可用的编程语言（区别于专门用于研究的语言），因此，正如 C.A.R Hoare 在他关于语言设计的经典论文中建议的那样，Java 语言的设计里避免引入那些新颖但未经验证的特性。

Java 是一个强静态类型的语言。在本语言规范中明确区分**编译时（compile-time）**错误和运行时错误，其中编译时错误必须在编译阶段就被检测到。编译时一般包括把程序转译成为平台无关的字节码的过程。运行时（Run-time）一般包括加载和链接程序运行需要的类、机器码的生成（可选）和程序片段的动态优化、以及实际的程序执行。

Java 是一个相对高阶的编程语言，语言规范中不包括任何机器码相关的内容。它包含自动内存管理机制，通过垃圾回收器来避免显式释放内存的安全问题（类比 C 中的 free 语句和 C++ 中的 delete 语句）。高性能的垃圾回收实现可以做到可控时间的停顿从而支持系统类编程和实时应用。Java 编程语言不包含任何不安全的结构，比如未经索引检查访问一个数组，因为这种不安全的结构会导致程序以一种非特定的方式进行执行。

Java 编程语言一般被编译成为字节码指令集的二进制格式，后者的规范可以参考 Java 虚拟机规范。

## 1.1 每章内容简要

第 2 章描写了用来表示 Java **词法**和**句法**的语法及标记。

第 3 章描写了 Java 编程语言基于 C 和 C++ 的词法结构。它使用了 Unicode 字符集，并且支持在纯 ASCII 的系统上编写 Unicode 字符。

第 4 章描写了类型、值和变量。其中类型又可以分为主类型和引用类型。

主类型在所有的机器及实现中被定义为一模一样的，包括不同位数的二进制的整形、单精度和双精度 IEEE754 标准的浮点数、布尔（boolean）类型 和表示 Unicode 字符的 char 类型。主类型的值不共享状态（应该是区别与引用类型来说）。

引用类型包括**类**、**接口**和**数组**三种。引用类型通过动态创建类或者数组的实例对象来实现。这就意味着每个对象可以有很多引用。所有的对象（包括数组实例）均支持 `Object` 类的方法，也就是说，`Object` 是类继承中唯一的根类（最顶层的基类）。预定义的 `String` 类支持 Unicode 字符串。存在一些包装主类型值的类。在很多时候，**包装**和**拆包**是在编译时就自动完成的。可以定义泛型的类和接口，通过其他的引用类型来定制化类和接口，使用时传入特定类型的参数来触发泛型声明。

变量是带类型的存储地址。主类型的变量保存的是指定的主类型的值。某个类的变量可以保存 null 引用或指定类及其任何子类的对象引用。接口的变量可以保存 null 引用或任何实现了此接口的类的实例的引用。数组的变量可以保存 null 引用或者某个数组的引用。类 Object 类型的变量可以保存 null 引用以及任何对象（包括类实例、数组）的引用。

第 5 章介绍了转换和**数字提升**。转换能够改变编译时的类型，有时候也会改变表达式的值。在所描述的转换中包括主类型和引用类型之间的包装和拆包转换。数字提升用来把数字运算符的操作数转换为对应的运算所需要的通用类型。语言中不存在转换漏洞；引用类型的转换会在运行时进行检查从而保证类型安全。

第 6 章介绍了声明与命名，并介绍了如何确定名称的含义。Java 并不要求类型或其成员必须在使用前进行声明，（可以在使用的时候同时声明）。声明顺序的重要性仅局限在本地变量、本地类、以及某个类或接口的成员字段的初始化顺序。

在 Java 语言中可以控制名称的作用域，支持**包成员、类成员和接口成员**被外部其他包访问的限制。通过类型的具体实现（提供不同的访问权限）来区分的使用者和扩展（extend）者，使得 Java 能够编写大型的程序代码。最后，为了让开发者写出可读性更好的代码，本章最后还介绍了一些命名上约定。

第 7 章介绍了程序的结构，主要以包（package）的形式进行组织，类似 Modula 里的模块（modules）。包的成员包括类、接口和子包。在 Java 中，包也是基本的编译单元，其中每个编译单元均包含类型声明，还可以从其他包导入类型并且定义一个短名称。包在分层的命名空间中保存名称，一般情况下可以使用域名系统来构建包名（类似 com.jianzhoubian.message.push）。

第 8 章介绍了类（class)。类的成员可以是类、接口、字段（变量）和方法。**类变量**仅存在于类中；**类方法**也不必通过类的具体实例再调用（可以直接通过类名调用）。**实例变量**会在类实例化的对象中动态创建；实例方法只能在类的实例对象上进行调用，其执行过程中 `this` 表示触发当前方法的实例（面向对象的编程方式）。

类仅支持单继承，意味着每个类只能有一个超类（superclass），且均从最顶层的 Object 类依次继承而来。某个类的变量可以引用对应类及其子类的实例，允许新类型多态地使用已存的方法。

类通过 synchronized 方法支持并发编程。可以在方法定义时声明执行过程中可能抛出的异常，这种情况下编译器可以检测确保对应的异常情况被处理了。对象可以声明 finalize 方法，这个方法会在对象被垃圾回收器回收之前触发，允许对象清理自己的状态。

为了简化，Java 既没有分离的头文件，也没有分离的类型和类层级文件（C 和 C++ 存在类似的结构）。

枚举（enum）属于特殊的类，它以一种安全的方式支持定义并管理某类值的小集合。不像其他的编程语言，Java 中的枚举属于对象，可以有自己的方法（可以在枚举上面调用方法）。

第 9 章介绍了接口类型。可以在接口类型中声明一系列的抽象方法、成员类型和常量等。不相干的类可以实现相同的接口类型。某个接口类型的变量可以指向任何实现了这个接口的类的实例对象。接口支持多继承。

注解类型是用来声明注解的特殊接口。这些注解不能够影响 Java 编程语言的正常句法（不能因为引入注解使的编译后的代码不满足 Java 语言规范）。不过，可以给某些工具提供有用的输入。

第 10 章介绍了数组。数组访问包含了边界检查。数组属于动态创建的对象，可以被赋值给 Object 类型的变量。Java 支持数组的数组类型，不支持多维的数组。

第 11 章介绍了异常。异常属于未能恢复的事件，整个异常机制完全集成在了 Java 的句法和并发机制中。Java 中总共有 3 类异常：**已知异常、运行时异常、错误**。编译器会检查某个方法或者构造器抛出的已知异常是否是这个方法或对应的构造器声明时定义的已知异常，从而确保已知异常被正确处理了。这个机制可以让编译时检查异常处理逻辑的存在，利于构建大型程序。大部分用户定义的异常都应该属于这类已知异常。由 Java 虚拟机检测到的非法操作属于运行时异常，比如 `NullPointerException`。由 Java 虚拟机检测到的失败操作属于错误，比如 `OutOfMemoryError`。大部分程序代码不会尝试捕获错误。

第 12 章介绍了程序执行时发生的一些过程。程序最初以类和二进制文件的形式存在（通过编译类和接口产生二进制字节码），这些二进制文件加载到 Java 虚拟机后，可以被链接到其他的类和接口然后被初始化。

初始化以后，类方法和类变量就可以直接使用了。一些类可以被实例化成为对象。每个类实例化后的对象中同时包含了其超类的一个实例，因此对象的创建包含一个递归创建超类实例的过程。

当一个对象不再被引用，它可能会被垃圾回收起回收掉。如果一个对象声明了一个终结器(finalizer)，这个终结器会在对象被回收前触发执行，这是对象清理某些不可自动释放的资源的最后机会。当一个类不再需要的时候，它可能会被从 Java 虚拟机中卸载掉。

第 13 章介绍了二进制兼容性，指定了某个类型的改变对使用了这个类型但是尚未重新编译过的其他类型的影响。这些注意事项对那些通过互联网连续发版的开发者尤其重要。好的开发环境可以在一个类型改变时自动重新编译，因此大部分的程序员不需要关注这些细节。

第 14 章介绍了代码块（blocks）和代码语句（statements），基本上沿用了 C 和 C++ 中类似的逻辑。在 Java 中不包含 goto 语句，不过相应的 break 和 continue 语句可以添加标签。不像 C 语言，Java 中的控制流语句必须使用布尔（boolean/Boolean）表达式，如果不能隐式转换成布尔类型的值，会在编译时就报错。同步（synchromized）语句提供了对象级别的监视器（monitor）锁。try 语句可以包含 catch 和 finally 来防止非本地控制权的转换。

第 15 章介绍了表达式。本文档完全明确地指定了表达式执行的顺序，从而提高表达的准确性和可移植性。重载的方法和构造器在编译时就被确认使用哪一个（一般选择最明确功能的那一个）。

第 16 章介绍了 Java 为确保本地变量使用前能够被正确设置的方式。在 Java 中其他的变量都会被初始化为默认值，为了避免掩盖编程错误，本地变量不会被自动初始化。

第 17 章介绍了线程和锁的句法，是在基于监视器（monitor-based）并发的基础上实现的，后者最初在 Mesa 编程语言中被引入。Java 编程语言指定了一种内存模型，指定了多 CPU 核共享存储情况下高性能的实现规范。

第 18 章介绍了各种类型推断算法，这些算法用户测试泛化方法的适应性，并在泛化方法中推断类型。

第 19 章展示了 Java 语言的句法。

## 1.2 示例程序

大部分的给出的示例程序都是可以直接运行的，类似下面的形式：

```java
class Test {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++)
            System.out.print(i == 0 ? args[i] : " " + args[i]);
        System.out.println();
    }
}
```

如果上述代码片段保存在 Test.java 文件中，可以在安装了 Oracle 的 JDK 的机器上运行下面的命令来编译和执行它：

```bash
javac Test.java
java Test Hello, world.
```

上面的命令会输出：

```bash
Hello, world.
```

## 1.3 符号

规范中引用了 Java SE 平台 API 中的类和接口。每当通过一个单独的符号 N 引用某个类或者方法的时候，都是指的引用 java.lang 包里对应的类或者接口（示例中定义的类或接口除外）。其他包的类或者接口通过全称表示。
