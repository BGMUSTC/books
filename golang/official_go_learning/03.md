# 名称

和其他编程语言类似，命名在 Go 语言中也很讲究。Go 中的命名甚至属于语法的一部分：名称的首字母是否大写决定这个名称在包外的可见性。因此很有必要花一些时间来了解 Go 程序中的命名规范。

## 包名

当包被导入（import）后，包名会成为包的访问器。比如，在 `import "bytes"` 后，导入此包的文件就可以使用 `bytes.Buffer` 来访问 `bytes` 包内的 `Buffer` 结构体了。如果使用某包的所有源代码都通过包名调用这个包的内容，这就意味着这个包的包名名称应该足够好：短、简洁且释义。按照惯例，包名应该是小写字符、且应该是一个独立的单词；包名里不应该包含下划线，也不应该是驼峰样式的名称。如果你定义了一个包，包名应该尽可能地简单，因为每个使用这个包的人都需要一个字符一个字符地把包名敲出来（字符太多敲起来麻烦）；我们不需要担心我们的包名和已经存在的包名称上会冲突；对于导入某个包的源码来说，包名指定了默认的访问器名称，不过没有必要在所有导入这个包的源码中都使用这个默认的名称。

很少的情况下，同一个源文件中导入的两个包可能有相同的包名，这时候给冲突的包定义一个新的本地访问器名称就可以了。

```go
import (
	"github.com/chalvern/sugar"
	log "github.com/chalvern/sugar"
)

// 同样都是 "github.com/chalvern/sugar"，但是可以设置不同的别名
// 如果不设置别名，默认是 `sugar`
sugar.Info("hello sugar")
log.Info("hello log")
```

导入包的时候使用的是包的全路径（比如 `"github.com/chalvern/sugar"`），它唯一决定了使用的是哪个包，因此即使出现了另一个名为 `sugar` 的包，使用上也不会出现混淆。

另一个约定是，包名一般设置为它的源文件所在的目录名，比如目录 `src/encoding/base64` 定义的包引入时的路径是 `"encoding/base64"`，我们应该把包名定义为`base64`，不应该写成 encoding_base64，也不应该写成 encodingBase64。

一个包被导入后一般通过它的包名来访问其内容，因此在包中导出的名字可以借助包名来避免含糊不清（不要在源文件中使用 `import . package/name` 的方式导入包，否则包里的名称很容易与源文件夹中的名称混淆）。比如，在 `bufio` 包里带缓存的读类型应该是 Reader 而不是 BufReader, 因为当开发者看到 `bufio.Reader` 的时候就已经知道这是个带缓存的 Reader 了，这种方式的定义不仅简洁而且不失准确性。进一步讲，因为被导入的实体经常与他们的包名一起取用，因此 `bufio.Reader` 和 `io.Reader` 虽然都是 `Reader` 但是二者是不会冲突的。同样的道理，对于包 [ring](https://golang.google.cn/pkg/container/ring/)，包里包含唯一导出的 `Ring` 结构体，创建 `Ring` 的新对象的函数按一般的思维可以被命名为 `NewRing()`，但是因为 `Ring` 是包里唯一导出的类型，并且因为包名叫 `ring`，因此这个创建新对象的方法可以命名为 `New()`，这样使用这个包的调用方就可以通过 `ring.New()` 来创建 `Ring` 的对象了（是不是感觉很简单）。总之，根据包的这些使用规范来选择一个好名称吧。


另一个短小精悍的例子是 `once.Do`，`once.Do(setup)` 读起来自然且流畅，如果把名字改成 `once.DoOrWaitUntilDone(setup)` 好像并没有必要。长名称并不会让事物更具有可读性。相对于长的命名方式，注释文档往往具有有更高的价值。

## 获取器(Getters)

Go 并没有对获取器（getter）和设置器（setter）提供自动的支持。如果你自己提供获取器和设置器，也没有什么问题，而且一般推荐这么做；但是把 Get 放进获取器的名字里显得既不明智也没有必要。如果有一个名为 owner 的字段（小写，非导出），获取器的名字应该叫 Owner（大写字母，可导出），而不是 GetOwner。大写字母名称可以导出，这种用法提供了一种机制使方法名与字段名可以不同。在设置器函数必要的情况下，可以取名为 SetOwner。如此，两个名字读起来都很流畅：

```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

## 接口名

通常情况下，只有一个方法的接口被命名为其包含的方法名加一个 "-er" 后缀，或者同样的方式构造一个代理名词：Reader, Writer, Formatter, CloseNotifier 等。

有许多这种卓有成效的名称，对应的包以及包内的方法都被人们熟知。Read, Write, Close, Flush, String有规范的签名和含义。为了避免混淆，除非你的方法有相同的签名和含义，否则不要以这些名字命名。相反，如果你自己的类型有一个方法和某个已存在类型的方法功能相似，此时建议取相同的名字就可以。比如你定义了一个字符串转换器的方法，应该直接命名为 String ，不要命名为 ToString。


## 混合驼峰

最后，Go 惯例中使用混合驼峰 MixedCaps 或 mixedCaps 来组织多个单词的名称，不推荐使用下划线的方式。