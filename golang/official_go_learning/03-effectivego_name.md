# 名称

和其他编程语言类似，命名在 Go 语言中也很讲究。Go 中的命名甚至属于语法的一部分：名称的首字母是否大写决定这个名称在包外的可见性。因此很有必要花一些时间来了解 Go 程序中的命名规范。

## 包名

当包被导入（import）后，包名会成为包的访问器。比如，在 `import "bytes"` 后，导入此包的文件就可以使用 `bytes.Buffer` 来访问 `bytes` 包内的 `Buffer` 结构体了。如果使用某包的所有源代码都通过包名调用这个包的内容，这就意味着这个包的包名名称应该足够好：短、简洁且释义。按照惯例，包名应该是小写字符、且应该是一个独立的单词；包名里不应该包含下划线，也不应该是驼峰样式的名称。如果你定义了一个包，包名应该尽可能地简单，因为每个使用这个包的人都需要一个字符一个字符地把包名敲出来（字符太多敲起来麻烦）；我们不需要担心我们的包名和已经存在的包名称上会冲突；对于导入某个包的源码来说，包名指定了默认的访问器名称，不过没有必要在所有导入这个包的源码中都使用这个默认的名称。

很少的情况下，同一个源文件中导入的两个包可能有相同的包名，这时候给冲突的包定义一个新的本地访问器名称就可以了。

```go
import (
	"github.com/chalvern/sugar"
	log "github.com/chalvern/sugar"
)

// 同样都是 "github.com/chalvern/sugar"，但是可以设置不同的别名
// 如果不设置别名，默认是 `sugar`
sugar.Info("hello sugar")
log.Info("hello log")
```

导入包的时候使用的是包的全路径（比如 `"github.com/chalvern/sugar"`），它唯一决定了使用的是哪个包，因此即使出现了另一个名为 `sugar` 的包，使用上也不会出现混淆。

另一个约定是，包名一般设置为它的源文件所在的目录名，比如目录 `src/encoding/base64` 定义的包引入时的路径是 `"encoding/base64"`，我们应该把包名定义为`base64`，不应该写成 encoding_base64，也不应该写成 encodingBase64。

一个包被导入后一般通过它的包名来访问其内容，因此在包中导出的名字可以借助包名来避免含糊不清（不要在源文件中使用 `import . package/name` 的方式导入包，否则包里的名称很容易与源文件夹中的名称混淆）。比如，在 `bufio` 包里带缓存的读类型应该是 Reader 而不是 BufReader, 因为当开发者看到 `bufio.Reader` 的时候就已经知道这是个带缓存的 Reader 了，这种方式的定义不仅简洁而且不失准确性。进一步讲，因为被导入的实体经常与他们的包名一起取用，因此 `bufio.Reader` 和 `io.Reader` 虽然都是 `Reader` 但是二者是不会冲突的。同样的道理，对于包 [ring](https://golang.google.cn/pkg/container/ring/)，包里包含唯一导出的 `Ring` 结构体，创建 `Ring` 的新对象的函数按一般的思维可以被命名为 `NewRing()`，但是因为 `Ring` 是包里唯一导出的类型，并且因为包名叫 `ring`，因此这个创建新对象的方法可以命名为 `New()`，这样使用这个包的调用方就可以通过 `ring.New()` 来创建 `Ring` 的对象了（是不是感觉很简单）。总之，根据包的这些使用规范来选择一个好名称吧。


另一个短小精悍的例子是 `once.Do`，`once.Do(setup)` 读起来自然且流畅，如果把名字改成 `once.DoOrWaitUntilDone(setup)` 好像并没有必要。长名称并不会让事物更具有可读性。相对于长的命名方式，注释文档往往具有有更高的价值。

## 获取器(Getters)

Go 并没有对获取器（getter）和设置器（setter）提供自动的支持；不过我们可以自己提供获取器和设置器，而且一般也推荐这么做；但是对 Go 语言来说把 Get 放进获取器的名字里显得既不明智也没太大必要。比如一个结构体有一个名为 `owner` 的字段（小写，意味着非导出，在包外不能直接访问这个变量），它的获取器的名字应该叫 `Owner()`（大写字母，可导出），而不是 `GetOwner()`。在 Go 语言中大写字母名称可以导出，这种机制使方法名与字段名可以不冲突，不需要添加 `Get` 就可以满足我们的需求了。假如设置器函数是必须的，设置器函数可以取名为 `SetOwner()`，这个时候就要加上 `Set` 这个单词了（这里或许有点过头了。。）。如此，下面的代码读起来都很流畅：

```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

## 接口名

通常情况下，只有一个方法的接口的名称是方法名加 "er" 后缀，或者类似构造而成的代理名词，比如：Reader, Writer, Formatter, CloseNotifier 等。这种命名方式有许多被开发者熟知的接口以及方法。

以 Read, Write, Close, Flush, String 等命名方法都有规范的签名（声明）和含义；为了避免混淆，你自己的方法除非有相同的签名和含义，否则不要以这些名字命名。而假如自定义的类型存在一个方法和某个已存的类型的方法功能相似，这个时候取相同的名字就可以了。比如假如你定义了一个字符串转换的方法，直接命名为 `String` 而不要命名为 `ToString`。


## 混合驼峰式命名

最后，Go 惯例中使用混合驼峰 MixedCaps 或 mixedCaps 来组织多个单词组合的名称，不推荐使用下划线的方式。